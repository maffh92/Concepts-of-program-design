--Call by name and call by value

scala> val matthew = new Human("Matthew",24)
matthew: TraitsExample.Human = TraitsExample.Human@1f782c05

scala> val noName = new Human(age=18, name="NoName")
noName: TraitsExample.Human = TraitsExample.Human@42e4e589


We have a dog 
scala> val jack = new Dog("Jack")
jack: TraitsExample.Dog = TraitsExample.Dog@7c5df615
scala> jack.sound
Woof!

scala> val max = new Dog("max"){ override def sound = "run" }
max: TraitsExample.Dog = $anon$1@3434a4f0



------------------------------------------------------------------

Mutable and immutable

scala> val number = 10
number: Int = 10

scala> number = 12
<console>:12: error: reassignment to val
       number = 12

scala> var number = 10
number: Int = 10

scala> var number = 5
number: Int = 5

------------------------------------------------------------------

scala> val values : List[Int] = List(1,2,3,4,5,6,7,8,9,10)

values: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

scala> values.map(plus(1))
<console>:16: error: not found: value plus
       values.map(plus(1))
                  ^

scala> values.map(Calculator.plus(1))
res1: List[Int] = List(2, 3, 4, 5, 6, 7, 8, 9, 10, 11)

scala> values.map(Calculator.minus(1))
<console>:16: error: not enough arguments for method minus: (x: Int, y: Int)Int.
Unspecified value parameter y.
       values.map(Calculator.minus(1))
                                  ^

--Anonymous function:
scala> values.map(x => x + 1)
res3: List[Int] = List(2, 3, 4, 5, 6, 7, 8, 9, 10, 11)


--Class relationship
scala> Children(new Parent)
<console>:12: error: inferred type arguments [Parent] do not conform to method apply's type parameter bounds [A <: Child]
       Children(new Parent)
       ^
<console>:12: error: type mismatch;
 found   : Parent
 required: A
       Children(new Parent)


--Difference Objects, class, abstract classes and traits
//Object do not allow parameters
Object is a singleton, it is already instantiated
//Abstract classes not be instantiated, but I don't see any difference in comaring to the normal classes
class needs to new keyword

case object and classes are used for pattern matching


Function types:
The function type A => B is just an abreviation for the class scala.Function1[A,B], which is roughly defined as follows:

package scala
trait Function1[A,B]{
	def apply(x : A) : B
}

traits Function2...Function22

Anonymous function
(x : Int) => x + 1

This will be expanded to  (Same syntax as Java)
new Function1[Int,Int]{
	def apply(x : Int) : Int = x + 1
}


A function call, such as f(a,b), where f is a value of some class type, is expanded to
f.apply(a,b)
So, the OO-translation of 
val f = (a : Int, b : Int) => a + b
f(2,3)
or 
val f = (a : Int)(b : Int) => a + b


--------------------------------------------
Note that a method such as
def f(x : Int) : Boolean = ...
is not itself a function value
But if f is used in a place where a Function type is expected, it is converterted automatically to the Function value: (x : Int) => f(x) <- this is called eta-expansion


Translation of Tuples
A tuple type(T1,...,Tn) is an abbreviation of the parameterized type
scala.TupleN[T1,...,Tn]

A Tuple expression (e1,...,eN) is equivalent to the function application
scala.Tuple(e1,...,eN)

A Tuple pattern (p1,...,pN) is equivalent to the constructor pattern
scala.TupleN(p1,...,pN)


The Tuple class
Here, all TupleN classes are modeled after the following pattern:
case class Tuple2[T1,T2](_1 : +T1, _2 +T2){
	override def toString = "(" + _1 + "," + _2 + ")"
}

The fields of the tuple can be accessed with name _1, _2 ...
So instead of the pattern binding
val pair = ("Hello",5)
val (v1,v2) = pair
val v1 = pair._1
val v2 = pair_2

List compresion in Haskell and Scala


Anonymous functions
scala> var f = (x : Int,y : Int) => x + 1
f: (Int, Int) => Int = $$Lambda$1092/2081595126@42d73c61

scala> var f = (x : Int) => (y : Int) => x + 1
f: Int => (Int => Int) = $$Lambda$1113/551797833@2c58dcb1

scala> f(1)
res0: Int => Int = $$Lambda$1130/1813375175@56380231

scala> f(1)(2)
res1: Int = 2

